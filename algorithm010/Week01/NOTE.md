# 学习笔记

---
## 知识点分析

### 数组： 
**要点：**  
**1.一段连续的内存储存相通的类型的值**
**2.查找的时间复杂度低，插入删除的时间复复杂度**

### 链表： 
**要点：**  
**1.空间上不连续的数据结构，用于存储相通类型的数据**
**2.查找的时间复杂度高，插入删除的时间复复杂度**

 
### 栈（stack）： 
**要点：**  
**1.FILO：first in last out.**
**2.有特殊的方法，push,pop,peek,empty**
**3.空间复杂度为：O(n)，时间复杂度：查找和接入都为O(n)，插入和删除都为O(1)**
**4.对于内外对称性的题目，可以用栈来进行求解，比如**

### 队列（queue）： 
**要点：**  
**1.FIFO：first in first out.**
**2.有特殊的方法，push,pop,peek,empty**
**3.空间复杂度为：O(n)，时间复杂度：查找和接入都为O(n)，插入和删除都为O(1)**


---
## 题目分析

### 1. 两数之和

**要点：**  
**1.数据结构是数组**
**2.两个数的和等于target**

#### 思路：
>因为两数之和为target，使用hash table可以很比较快速的确定两个数。  
>hash table的查询效率非常高。 所以把一个数作为key，另一个数作为value，正好可以解决这个问题。如果是三数之和不适用这种方式。  
><font color=#00ffff>时间：O(1),空间：O（n）</font>

### 21. 有效括号

**要点：**  
**1.数据结构是栈**
**2.对称性**

#### 思路：
>这个题是一个以一对对称的括号来考察问题的。
>使用hash map来进行对的储存，提高访问效率。  
>使用栈来进行对这些对称性的比较，对称性相同就pop，不同的话就push。  
><font color=#00ffff>PS：但是递归的话时间复杂度会很高。</font>

### 21. 合并两个有序链表

**要点：**  
**1.数据结构是链表**
**2.结束的标致应该是链表的下一个节点是nil**
**3.适合使用递归**

#### 思路：
>这个函数的API是两个节点，所以可以考虑递归。递归的终止条件可以是节点为nil  
>如果一个链表的下一个节点为nil，就可以直接返回下一个链表。  
><font color=#00ffff>PS：但是递归的话时间复杂度会很高。</font>

### 26. 删除排序数组中的重复项

**要点:**  
**1. 有序**  
**2. 在原有基础上修改和覆盖**

#### 思路：
>已经有序了，所以可以考虑通过一个for loop进行遍历  
>设定一个与重复有关系索引i，并且每当循环的时候遇到一个重复的数，就把这个数给这个索引所在的位置，下一次再出现这个这个数的时候，就不再更新这个值，因为更新的肯定是已经遍历过的位置，所以不存在覆盖。  
>重要的是，这样的话时间复杂度是常量级别的O(1),空间复杂度也是O(1)  

### 66. 加一

**要点：**  
**1.数据结构是数组**
**2.可能增加数组的长度**
**3.类似于笔算式**

#### 思路：
>把数组看做一个int数值，所以加一应该从个位加一。
>如果最后的个位数是9，加一之后就要向前进一位，这时需要再判断下一位是不是需要进位。当出现极端情况，比如*999*，*-1*。 需要特别拿出来分析，这时临界条件。 
>所以如果需要在数组最开头还进一位的话，则需要进行扩容，在数组头部加1，其他全部置位0。   
>*-1*情况非常特殊，所以当只有一位切为负数时，加一不论怎样都不会改变新生成的数组的大小。   
><font color=#00ffff>时间：O(1),空间：O（n）</font>

### 88. 合并两个有序数组

**要点：**  
**1.数据结构是数组**
**2.有序**
**3.内存上刚好大小合适进行合并**

#### 思路：
>因为第一个数组的最后可以看做是空的并且可以放值的地方。所以我们的思路是从后往前遍历，找到一个大的值就先放下。
>用i，j两个索引分别找出当前数组的值并将相应的索引值，并且把已经放入最大值的那个数组的索引减一。  
><font color=#00ffff>时间：O(1),空间：O（1）</font>

### 189. 旋转数组

**要点：**  
**1.不可新开一段内存空间**
**2.需要注意临界条件**

#### 思路：
>**k>=切片的长度:**   
>  直接用反转的方法对整个数组进行反转就好了  
>**K<切片长度:**  
>使用append函数进行切割，把最后的k个元素切割以后插入到切片的第一个位置。  
><font color=#00ffff>PS：这个时候append函数其实开了一个新的位置，但是这题不允许我们新开一个内存位置，所以需要用copy进行对原内存地址的修改。</font>

### 283. 移动零

**要点：**  
**1.数据结构是数组**
**2.在原数组上进行修改**

#### 思路：
>因为是一个数组，所以想到遍历。需要在原数组上进行修改，并且是修改值。可以做指标的应该是索引。  
>因为只需要遍历一次，所以用一个临时的变量来存储索引，然后一旦发现不是零值，就往当前索引所在的地方赋值。然后索引变量加一。  
><font color=#00ffff>时间：O(1),空间：O（n）</font>

